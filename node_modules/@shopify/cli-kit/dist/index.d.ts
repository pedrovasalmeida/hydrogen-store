import { AbortController, AbortSignal } from 'abort-controller';
import { Writable, Readable } from 'node:stream';
import { ExtendableError } from 'ts-error';
import { RequestDocument, Variables } from 'graphql-request';
import * as _oclif_core_lib_interfaces from '@oclif/core/lib/interfaces';
import { Plugin } from '@oclif/core/lib/interfaces';
import * as fastify from 'fastify';
export { fastify };
import * as simple_git from 'simple-git';
import nodeFetch, { RequestInfo, RequestInit } from 'node-fetch';
import FormData from 'form-data';
import { platform } from 'node:process';
import * as pathe from 'pathe';
import { findUp } from 'find-up';
import fastGlob from 'fast-glob';
import { pathToFileURL } from 'node:url';
import { z } from 'zod';
import semver$1 from 'semver/classes/semver';
import coerce from 'semver/functions/coerce';
import Conf from 'conf';
import { camelCase, paramCase, snakeCase, constantCase } from 'change-case';
import * as toml$1 from '@iarna/toml';
import { Listr, ListrTaskWrapper, ListrDefaultRenderer, ListrTask } from 'listr2';

function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

declare const constants: {
    environmentVariables: {
        unitTest: string;
        shopifyConfig: string;
        runAsUser: string;
        partnersEnv: string;
        shopifyEnv: string;
        identityEnv: string;
        spin: string;
        spinInstance: string;
        spinWorkspace: string;
        spinNamespace: string;
        spinHost: string;
        partnersToken: string;
        verbose: string;
        noAnalytics: string;
    };
    paths: {
        executables: {
            dev: string;
        };
        directories: {
            cache: {
                path: () => string;
                vendor: {
                    path: () => string;
                    binaries: () => string;
                };
            };
        };
    };
    /**
     * Versions are resolved at build time by Rollup's JSON plugin.
     */
    versions: {
        cliKit: string;
    };
    keychain: {
        service: string;
    };
    session: {
        expirationTimeMarginInMinutes: number;
    };
};

declare namespace abort {
  export {
    AbortController as Controller,
    AbortSignal as Signal,
  };
}

declare const url = "https://monorail-edge.shopifysvc.com/v1/produce";
declare const reportEvent: (command: string, args: string[]) => Promise<void>;

declare const analytics_url: typeof url;
declare const analytics_reportEvent: typeof reportEvent;
declare namespace analytics {
  export {
    analytics_url as url,
    analytics_reportEvent as reportEvent,
  };
}

declare const genericConfigurationFileNames: {
    readonly yarn: {
        readonly lockfile: "yarn.lock";
    };
    readonly pnpm: {
        readonly lockfile: "pnpm-lock.yaml";
    };
};
declare const dependencyManager: readonly ["yarn", "npm", "pnpm"];
declare type DependencyManager = typeof dependencyManager[number];
declare const PackageJsonNotFoundError: (directory: string) => Abort;
/**
 * Returns the dependency manager used to run the create workflow.
 * @param env {Object} The environment variables of the process in which the CLI runs.
 * @returns The dependency manager
 */
declare function dependencyManagerUsedForCreating(env?: NodeJS.ProcessEnv): DependencyManager;
/**
 * Returns the dependency manager used by an existing project.
 * @param directory {string} The root directory of the project.
 * @returns The dependency manager
 */
declare function getDependencyManager(directory: string): Promise<DependencyManager>;
interface InstallNPMDependenciesRecursivelyOptions {
    /**
     * The dependency manager to use to install the dependencies.
     */
    dependencyManager: DependencyManager;
    /**
     * The directory from where we'll find package.json's recursively
     */
    directory: string;
    /**
     * Specifies the maximum depth of the glob search.
     */
    deep?: number;
}
/**
 * This function traverses down a directory tree to find directories containing a package.json
 * and installs the dependencies if needed. To know if it's needed, it uses the "check" command
 * provided by dependency managers.
 * @param options {InstallNPMDependenciesRecursivelyOptions} Options to install dependencies recursively.
 */
declare function installNPMDependenciesRecursively(options: InstallNPMDependenciesRecursivelyOptions): Promise<void>;
/**
 * Installs the dependencies in the given directory.
 * @param directory {string} The directory that contains the package.json
 * @param dependencyManager {DependencyManager} The dependency manager to use to install the dependencies.
 * @param stdout {Writable} Standard output stream.
 * @param stderr {Writable} Standard error stream.
 * @param signal {AbortSignal} Abort signal.
 * @returns stderr {Writable} Standard error stream.
 */
declare function install(directory: string, dependencyManager: DependencyManager, stdout?: Writable, stderr?: Writable, signal?: AbortSignal): Promise<void>;
/**
 * Returns the name of the package configured in its package.json
 * @param packageJsonPath {string} Path to the package.json file
 * @returns A promise that resolves with the name.
 */
declare function getPackageName(packageJsonPath: string): Promise<string>;
/**
 * Returns the list of production and dev dependencies of a package.json
 * @param packageJsonPath {string} Path to the package.json file
 * @returns A promise that resolves with the list of dependencies.
 */
declare function getDependencies(packageJsonPath: string): Promise<{
    [key: string]: string;
}>;
declare function checkForNewVersion(dependency: string, currentVersion: string): Promise<string | undefined>;
declare function getOutputUpdateCLIReminder(dependencyManager: DependencyManager, version: string): string;
interface PackageJSONContents {
    name: string;
    version?: string;
    dependencies?: {
        [key: string]: string;
    };
    devDependencies?: {
        [key: string]: string;
    };
}
declare function packageJSONContents(packageJsonPath: string): Promise<PackageJSONContents>;
declare type DependencyType = 'dev' | 'prod' | 'peer';
interface AddNPMDependenciesIfNeededOptions {
    /** How dependencies should be added */
    type: DependencyType;
    /** The dependency manager to use to add dependencies */
    dependencyManager: DependencyManager;
    /** The directory that contains the package.json where dependencies will be added */
    directory: string;
    /** Standard output coming from the underlying installation process */
    stdout?: Writable;
    /** Standard error coming from the underlying installation process */
    stderr?: Writable;
    /** Abort signal to stop the process */
    signal?: AbortSignal;
}
interface DependencyVersion {
    name: string;
    version: string | undefined;
}
/**
 * Adds dependencies to a Node project (i.e. a project that has a package.json)
 * @param dependencies {string[]} List of dependencies to be added.
 * @param options {AddNPMDependenciesIfNeededOptions} Options for adding dependencies.
 */
declare function addNPMDependenciesIfNeeded(dependencies: DependencyVersion[], options: AddNPMDependenciesIfNeededOptions): Promise<void>;
declare function addNPMDependenciesWithoutVersionIfNeeded(dependencies: string[], options: AddNPMDependenciesIfNeededOptions): Promise<void>;
declare function addLatestNPMDependencies(dependencies: string[], options: AddNPMDependenciesIfNeededOptions): Promise<void>;

declare const dependency_genericConfigurationFileNames: typeof genericConfigurationFileNames;
declare const dependency_dependencyManager: typeof dependencyManager;
type dependency_DependencyManager = DependencyManager;
declare const dependency_PackageJsonNotFoundError: typeof PackageJsonNotFoundError;
declare const dependency_dependencyManagerUsedForCreating: typeof dependencyManagerUsedForCreating;
declare const dependency_getDependencyManager: typeof getDependencyManager;
declare const dependency_installNPMDependenciesRecursively: typeof installNPMDependenciesRecursively;
declare const dependency_install: typeof install;
declare const dependency_getPackageName: typeof getPackageName;
declare const dependency_getDependencies: typeof getDependencies;
declare const dependency_checkForNewVersion: typeof checkForNewVersion;
declare const dependency_getOutputUpdateCLIReminder: typeof getOutputUpdateCLIReminder;
declare const dependency_packageJSONContents: typeof packageJSONContents;
type dependency_DependencyType = DependencyType;
type dependency_DependencyVersion = DependencyVersion;
declare const dependency_addNPMDependenciesIfNeeded: typeof addNPMDependenciesIfNeeded;
declare const dependency_addNPMDependenciesWithoutVersionIfNeeded: typeof addNPMDependenciesWithoutVersionIfNeeded;
declare const dependency_addLatestNPMDependencies: typeof addLatestNPMDependencies;
declare namespace dependency {
  export {
    dependency_genericConfigurationFileNames as genericConfigurationFileNames,
    dependency_dependencyManager as dependencyManager,
    dependency_DependencyManager as DependencyManager,
    dependency_PackageJsonNotFoundError as PackageJsonNotFoundError,
    dependency_dependencyManagerUsedForCreating as dependencyManagerUsedForCreating,
    dependency_getDependencyManager as getDependencyManager,
    dependency_installNPMDependenciesRecursively as installNPMDependenciesRecursively,
    dependency_install as install,
    dependency_getPackageName as getPackageName,
    dependency_getDependencies as getDependencies,
    dependency_checkForNewVersion as checkForNewVersion,
    dependency_getOutputUpdateCLIReminder as getOutputUpdateCLIReminder,
    dependency_packageJSONContents as packageJSONContents,
    dependency_DependencyType as DependencyType,
    dependency_DependencyVersion as DependencyVersion,
    dependency_addNPMDependenciesIfNeeded as addNPMDependenciesIfNeeded,
    dependency_addNPMDependenciesWithoutVersionIfNeeded as addNPMDependenciesWithoutVersionIfNeeded,
    dependency_addLatestNPMDependencies as addLatestNPMDependencies,
  };
}

declare function initiateLogging({ logDir, filename, }: {
    logDir?: string;
    filename?: string;
}): void;
declare enum ContentTokenType {
    Raw = 0,
    Command = 1,
    Json = 2,
    Path = 3,
    Link = 4,
    Heading = 5,
    SubHeading = 6,
    Italic = 7,
    ErrorText = 8,
    Yellow = 9,
    Cyan = 10,
    Magenta = 11,
    Green = 12
}
interface ContentMetadata {
    link?: string;
}
declare class ContentToken {
    type: ContentTokenType;
    value: Message;
    metadata: ContentMetadata;
    constructor(value: Message, metadata: ContentMetadata | undefined, type: ContentTokenType);
}
declare const token: {
    raw: (value: Message) => ContentToken;
    genericShellCommand: (value: Message) => ContentToken;
    json: (value: any) => ContentToken;
    path: (value: Message) => ContentToken;
    link: (value: Message, link: string) => ContentToken;
    heading: (value: Message) => ContentToken;
    subheading: (value: Message) => ContentToken;
    italic: (value: Message) => ContentToken;
    errorText: (value: Message) => ContentToken;
    cyan: (value: Message) => ContentToken;
    yellow: (value: Message) => ContentToken;
    magenta: (value: Message) => ContentToken;
    green: (value: Message) => ContentToken;
    packagejsonScript: (dependencyManager: DependencyManager, scriptName: string, ...scriptArgs: string[]) => ContentToken;
    successIcon: () => ContentToken;
    failIcon: () => ContentToken;
};
declare class TokenizedString {
    value: string;
    constructor(value: string);
}
declare type Message = string | TokenizedString;
declare function content(strings: TemplateStringsArray, ...keys: (ContentToken | string)[]): TokenizedString;
/** Log levels */
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'silent';
/**
 *
 * @returns {LogLevel} It returns the log level set by the user.
 */
declare const currentLogLevel: () => LogLevel;
declare const shouldOutput: (logLevel: LogLevel) => boolean;
/**
 * Ouputs information to the user. This is akin to "console.log"
 * Info messages don't get additional formatting.
 * Note: Info messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const info: (content: Message) => void;
/**
 * Outputs a success message to the user.
 * Success message receive a special formatting to make them stand out in the console.
 * Note: Success messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const success: (content: Message) => void;
/**
 * Outputs a completed message to the user.
 * Completed message receive a special formatting to make them stand out in the console.
 * Note: Completed messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const completed: (content: Message) => void;
/**
 * Ouputs debug information to the user. By default these output is hidden unless the user calls the CLI with --verbose.
 * Debug messages don't get additional formatting.
 * Note: Debug messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const debug: (content: Message) => void;
/**
 * Outputs a warning message to the user.
 * Warning messages receive a special formatting to make them stand out in the console.
 * Note: Warning messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const warn: (content: Message) => void;
/**
 * Prints a new line in the terminal.
 */
declare const newline: () => void;
/**
 * Formats and outputs a fatal error.
 * Note: This API is not intended to be used internally. If you want to
 * abort the execution due to an error, raise a fatal error and let the
 * error handler handle and format it.
 * @param content {Fatal} The fatal error to be output.
 */
declare const error$1: (content: Fatal) => Promise<void>;
declare function stringifyMessage(message: Message): string;
interface OutputProcess {
    /** The prefix to include in the logs
     *   [vite] Output coming from Vite
     */
    prefix: string;
    /**
     * A callback to invoke the process. stdout and stderr should be used
     * to send standard output and error data that gets formatted with the
     * right prefix.
     */
    action: (stdout: Writable, stderr: Writable, signal: AbortSignal) => Promise<void>;
}
/**
 * Use this function when you have multiple concurrent processes that send data events
 * and we need to output them ensuring that they can visually differenciated by the user.
 *
 * @param processes {OutputProcess[]} A list of processes to run concurrently.
 */
declare function concurrent(processes: OutputProcess[], callback?: ((signal: AbortSignal) => void) | undefined): Promise<void>;
declare function unstyled(message: string): string;
declare function shouldDisplayColors(): boolean;
declare function pageLogs(): Promise<void>;

declare const output_initiateLogging: typeof initiateLogging;
declare const output_token: typeof token;
type output_TokenizedString = TokenizedString;
declare const output_TokenizedString: typeof TokenizedString;
type output_Message = Message;
declare const output_content: typeof content;
type output_LogLevel = LogLevel;
declare const output_currentLogLevel: typeof currentLogLevel;
declare const output_shouldOutput: typeof shouldOutput;
declare const output_info: typeof info;
declare const output_success: typeof success;
declare const output_completed: typeof completed;
declare const output_debug: typeof debug;
declare const output_warn: typeof warn;
declare const output_newline: typeof newline;
declare const output_stringifyMessage: typeof stringifyMessage;
type output_OutputProcess = OutputProcess;
declare const output_concurrent: typeof concurrent;
declare const output_unstyled: typeof unstyled;
declare const output_shouldDisplayColors: typeof shouldDisplayColors;
declare const output_pageLogs: typeof pageLogs;
declare namespace output {
  export {
    output_initiateLogging as initiateLogging,
    output_token as token,
    output_TokenizedString as TokenizedString,
    output_Message as Message,
    output_content as content,
    output_LogLevel as LogLevel,
    output_currentLogLevel as currentLogLevel,
    output_shouldOutput as shouldOutput,
    output_info as info,
    output_success as success,
    output_completed as completed,
    output_debug as debug,
    output_warn as warn,
    output_newline as newline,
    error$1 as error,
    output_stringifyMessage as stringifyMessage,
    output_OutputProcess as OutputProcess,
    output_concurrent as concurrent,
    output_unstyled as unstyled,
    output_shouldDisplayColors as shouldDisplayColors,
    output_pageLogs as pageLogs,
  };
}

declare enum FatalErrorType {
    Abort = 0,
    AbortSilent = 1,
    Bug = 2
}
declare class CancelExecution extends Error {
}
/**
 * A fatal error represents an error shouldn't be rescued and that causes the execution to terminate.
 * There shouldn't be code that catches fatal errors.
 */
declare abstract class Fatal extends Error {
    tryMessage: string | null;
    type: FatalErrorType;
    constructor(message: Message, type: FatalErrorType, tryMessage?: Message | null);
}
/**
 * An abort error is a fatal error that shouldn't be reported as a bug.
 * Those usually represent unexpected scenarios that we can't handle and that usually require some action from the developer
 */
declare class Abort extends Fatal {
    constructor(message: Message, tryMessage?: Message | null);
}
declare class AbortSilent extends Fatal {
    constructor();
}
/**
 * A bug error is an error that represents a bug and therefore should be reported.
 */
declare class Bug extends Fatal {
    constructor(message: Message, tryMessage?: string | null);
}
/**
 * A function that handles errors that blow up in the CLI.
 * @param error Error to be handled.
 * @returns A promise that resolves with the error passed.
 */
declare function handler(error: Error): Promise<Error>;
declare function mapper(error: Error): Promise<Error>;
declare function isFatal(error: Error): boolean;
declare function shouldReport(error: Error): boolean;

type error_CancelExecution = CancelExecution;
declare const error_CancelExecution: typeof CancelExecution;
type error_Fatal = Fatal;
declare const error_Fatal: typeof Fatal;
type error_Abort = Abort;
declare const error_Abort: typeof Abort;
type error_AbortSilent = AbortSilent;
declare const error_AbortSilent: typeof AbortSilent;
type error_Bug = Bug;
declare const error_Bug: typeof Bug;
declare const error_handler: typeof handler;
declare const error_mapper: typeof mapper;
declare const error_isFatal: typeof isFatal;
declare const error_shouldReport: typeof shouldReport;
declare const error_ExtendableError: typeof ExtendableError;
declare const error_AbortSignal: typeof AbortSignal;
declare namespace error {
  export {
    error_CancelExecution as CancelExecution,
    error_Fatal as Fatal,
    error_Abort as Abort,
    error_AbortSilent as AbortSilent,
    error_Bug as Bug,
    error_handler as handler,
    error_mapper as mapper,
    error_isFatal as isFatal,
    error_shouldReport as shouldReport,
    error_ExtendableError as ExtendableError,
    error_AbortSignal as AbortSignal,
  };
}

/**
 * A scope supported by the Shopify Admin API.
 */
declare type AdminAPIScope = 'graphql' | 'themes' | 'collaborator' | string;
/**
 * It represents the options to authenticate against the Shopify Admin API.
 */
interface AdminAPIOAuthOptions {
    /** Store to request permissions for */
    storeFqdn: string;
    /** List of scopes to request permissions for */
    scopes: AdminAPIScope[];
}
/**
 * A scope supported by the Partners API.
 */
declare type PartnersAPIScope = 'cli' | string;
interface PartnersAPIOAuthOptions {
    /** List of scopes to request permissions for */
    scopes: PartnersAPIScope[];
}
/**
 * A scope supported by the Storefront Renderer API.
 */
declare type StorefrontRendererScope = 'devtools' | string;
interface StorefrontRendererAPIOAuthOptions {
    /** List of scopes to request permissions for */
    scopes: StorefrontRendererScope[];
}
/**
 * It represents the authentication requirements and
 * is the input necessary to trigger the authentication
 * flow.
 */
interface OAuthApplications {
    adminApi?: AdminAPIOAuthOptions;
    storefrontRendererApi?: StorefrontRendererAPIOAuthOptions;
    partnersApi?: PartnersAPIOAuthOptions;
}
interface AdminSession {
    token: string;
    storeFqdn: string;
}
interface OAuthSession {
    admin?: AdminSession;
    partners?: string;
    storefront?: string;
}
declare const PartnerOrganizationNotFoundError: () => Abort;
/**
 * Ensure that we have a valid session to access the Partners API.
 * If SHOPIFY_CLI_PARTNERS_TOKEN exists, that token will be used to obtain a valid Partners Token
 * If SHOPIFY_CLI_PARTNERS_TOKEN exists, scopes will be ignored
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Partners API.
 */
declare function ensureAuthenticatedPartners(scopes?: string[], env?: NodeJS.ProcessEnv): Promise<string>;
/**
 * Ensure that we have a valid session to access the Storefront API.
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Storefront API.
 */
declare function ensureAuthenticatedStorefront(scopes?: string[]): Promise<string>;
/**
 * Ensure that we have a valid Admin session for the given store.
 * @param store {string} Store fqdn to request auth for
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Admin API
 */
declare function ensureAuthenticatedAdmin(store: string, scopes?: string[]): Promise<AdminSession>;
/**
 * This method ensures that we have a valid session to authenticate against the given applications using the provided scopes.
 * @param applications {OAuthApplications} An object containing the applications we need to be authenticated with.
 * @returns {OAuthSession} An instance with the access tokens organized by application.
 */
declare function ensureAuthenticated(applications: OAuthApplications, env?: NodeJS.ProcessEnv): Promise<OAuthSession>;
declare function hasPartnerAccount(partnersToken: string): Promise<boolean>;
/**
 * If the user creates an account from the Identity website, the created
 * account won't get a Partner organization created. We need to detect that
 * and take the user to create a partner organization.
 * @param partnersToken {string} Partners token
 */
declare function ensureUserHasPartnerAccount(partnersToken: string): Promise<void>;
declare function logout(): Promise<void>;

type session_OAuthApplications = OAuthApplications;
type session_AdminSession = AdminSession;
type session_OAuthSession = OAuthSession;
declare const session_PartnerOrganizationNotFoundError: typeof PartnerOrganizationNotFoundError;
declare const session_ensureAuthenticatedPartners: typeof ensureAuthenticatedPartners;
declare const session_ensureAuthenticatedStorefront: typeof ensureAuthenticatedStorefront;
declare const session_ensureAuthenticatedAdmin: typeof ensureAuthenticatedAdmin;
declare const session_ensureAuthenticated: typeof ensureAuthenticated;
declare const session_hasPartnerAccount: typeof hasPartnerAccount;
declare const session_ensureUserHasPartnerAccount: typeof ensureUserHasPartnerAccount;
declare const session_logout: typeof logout;
declare namespace session {
  export {
    session_OAuthApplications as OAuthApplications,
    session_AdminSession as AdminSession,
    session_OAuthSession as OAuthSession,
    session_PartnerOrganizationNotFoundError as PartnerOrganizationNotFoundError,
    session_ensureAuthenticatedPartners as ensureAuthenticatedPartners,
    session_ensureAuthenticatedStorefront as ensureAuthenticatedStorefront,
    session_ensureAuthenticatedAdmin as ensureAuthenticatedAdmin,
    session_ensureAuthenticated as ensureAuthenticated,
    session_hasPartnerAccount as hasPartnerAccount,
    session_ensureUserHasPartnerAccount as ensureUserHasPartnerAccount,
    session_logout as logout,
  };
}

declare function request$1<T>(query: RequestDocument, session: AdminSession, variables?: Variables): Promise<T>;

declare namespace admin {
  export {
    request$1 as request,
  };
}

declare class RequestClientError extends ExtendableError {
    statusCode: number;
    constructor(message: string, statusCode: number);
}
declare function request<T>(query: RequestDocument, token: string, variables?: Variables): Promise<T>;
/**
 * Check if the given token is revoked and no longer valid to interact with the Partners API.
 * @param token {string} - The token to check
 * @returns {Promise<boolean>} - True if the token is revoked, false otherwise
 */
declare function checkIfTokenIsRevoked(token: string): Promise<boolean>;
/**
 * Function queries are proxied through the script service proxy.
 * To execute a query, we encapsulate it inside another query (including the variables)
 * This is done automatically, you just need to provide the query and the variables.
 *
 * @param apiKey {string} APIKey of the app where the query will be executed.
 * @param query {any} GraphQL query to execute.
 * @param token {string} Partners token
 * @param variables {any} GraphQL variables to pass to the query.
 * @returns {Promise<T>} The response of the query.
 */
declare function functionProxyRequest<T>(apiKey: string, query: unknown, token: string, variables?: unknown): Promise<T>;

type partners$2_RequestClientError = RequestClientError;
declare const partners$2_RequestClientError: typeof RequestClientError;
declare const partners$2_request: typeof request;
declare const partners$2_checkIfTokenIsRevoked: typeof checkIfTokenIsRevoked;
declare const partners$2_functionProxyRequest: typeof functionProxyRequest;
declare namespace partners$2 {
  export {
    partners$2_RequestClientError as RequestClientError,
    partners$2_request as request,
    partners$2_checkIfTokenIsRevoked as checkIfTokenIsRevoked,
    partners$2_functionProxyRequest as functionProxyRequest,
  };
}

declare const FindOrganizationQuery: string;
interface FindOrganizationQuerySchema {
    organizations: {
        nodes: {
            id: string;
            businessName: string;
            website: string;
            appsNext: boolean;
            apps: {
                nodes: {
                    id: string;
                    title: string;
                    apiKey: string;
                    organizationId: string;
                    apiSecretKeys: {
                        secret: string;
                    }[];
                    appType: string;
                }[];
            };
        }[];
    };
}

interface AllOrganizationsQuerySchemaOrganization {
    id: string;
    businessName: string;
    website: string;
    appsNext: boolean;
}
interface AllOrganizationsQuerySchema {
    organizations: {
        nodes: AllOrganizationsQuerySchemaOrganization[];
    };
}
declare const AllOrganizationsQuery: string;

declare const CreateAppQuery: string;
interface CreateAppQueryVariables {
    org: number;
    title: string;
    appUrl: string;
    redir: string[];
    type: string;
}
interface CreateAppQuerySchema {
    appCreate: {
        app: {
            id: string;
            apiKey: string;
            title: string;
            applicationUrl: string;
            redirectUrlWhitelist: string[];
            organizationId: string;
            apiSecretKeys: {
                secret: string;
            }[];
            appType: string;
        };
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const UpdateURLsQuery: string;
interface UpdateURLsQueryVariables {
    apiKey: string;
    appUrl: string;
    redir: string[];
}
interface UpdateURLsQuerySchema {
    appUpdate: {
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const FindAppQuery: string;
interface FindAppQuerySchema {
    app: {
        id: string;
        title: string;
        apiKey: string;
        organizationId: string;
        apiSecretKeys: {
            secret: string;
        }[];
        appType: string;
    };
}

declare const ExtensionUpdateDraftMutation: string;
interface ExtensionUpdateDraftInput {
    apiKey: string;
    config: string;
    context: string | undefined;
    registrationId: string;
}
interface ExtensionUpdateDraftPayload {
    clientMutationId: string;
    extensionVersion: ExtensionVersion;
    userErrors: {
        field: string[];
        message: string;
    }[];
}
interface ExtensionVersion {
    config: string;
    context: string;
    id: string;
    lastUserInteractionAt: string;
    location: string;
    registrationId: string;
    registrationUuid: string;
    uuid: string;
    validationErrors: {
        field: string[];
        message: string;
    }[];
    versionTag: string;
}
interface ExtensionUpdateSchema {
    extensionUpdateDraft: ExtensionUpdateDraftPayload;
}

declare const GenerateSignedUploadUrl: string;
interface GenerateSignedUploadUrlVariables {
    apiKey: string;
    deploymentUuid: string;
    bundleFormat: number;
}
interface GenerateSignedUploadUrlSchema {
    deploymentGenerateSignedUploadUrl: {
        signedUploadUrl: string;
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const CreateDeployment: string;
interface ExtensionSettings {
    uuid: string;
    config: string;
    context: string;
}
interface CreateDeploymentVariables {
    apiKey: string;
    uuid: string;
    bundleUrl: string;
    extensions: ExtensionSettings[];
}
interface CreateDeploymentSchema {
    deploymentCreate: {
        deployment: {
            uuid: string;
        };
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const AllStoresByOrganizationQuery: string;
interface AllStoresByOrganizationSchema {
    organizations: {
        nodes: {
            id: string;
            stores: {
                nodes: {
                    shopId: string;
                    link: string;
                    shopDomain: string;
                    shopName: string;
                    transferDisabled: boolean;
                    convertableToPartnerTest: boolean;
                }[];
            };
        }[];
    };
}

declare const ConvertDevToTestStoreQuery: string;
interface ConvertDevToTestStoreVariables {
    input: {
        organizationID: number;
        shopId: string;
    };
}
interface ConvertDevToTestStoreSchema {
    convertDevToTestStore: {
        convertedToTestStore: boolean;
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const ExtensionCreateQuery: string;
interface ExtensionCreateVariables {
    apiKey: string;
    type: string;
    title: string;
    config: string;
    context?: string | null;
}
interface ExtensionCreateSchema {
    extensionCreate: {
        extensionRegistration: {
            id: string;
            uuid: string;
            type: string;
            title: string;
            draftVersion: {
                registrationId: string;
                lastUserInteractionAt: string;
                validationErrors: {
                    field: string[];
                    message: string;
                }[];
            };
        };
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const ExtensionSpecificationsQuery: string;
interface ExtensionSpecificationsQueryVariables {
    api_key: string;
}
interface ExtensionSpecificationsQuerySchema {
    extensionSpecifications: {
        name: string;
        identifier: string;
        options: {
            managementExperience: 'cli' | 'custom' | 'dashboard';
        }[];
        features?: {
            argo?: {
                surface: string;
            };
        };
    }[];
}

declare const AllAppExtensionRegistrationsQuery: string;
interface AllAppExtensionRegistrationsQueryVariables {
    apiKey: string;
}
interface AllAppExtensionRegistrationsQuerySchema {
    app: {
        extensionRegistrations: {
            id: string;
            uuid: string;
            title: string;
            type: string;
        }[];
    };
}

declare const FindProductVariantQuery: string;
interface FindProductVariantSchema {
    products: {
        edges: {
            node: {
                id: string;
                variants: {
                    edges: {
                        node: {
                            id: string;
                        };
                    }[];
                };
            };
        }[];
    };
}

declare const ScriptServiceProxyQuery: string;
interface ScriptServiceProxyQuerySchema {
    scriptServiceProxy: unknown;
}

declare const GetAppFunctionsQuery: string;

declare const ModuleUploadUrlGenerateMutation: string;
interface ModuleUploadUrlGenerateMutationSchema {
    data: {
        moduleUploadUrlGenerate: {
            details: {
                url: string;
                headers: {
                    [key: string]: string;
                };
                humanizedMaxSize: string;
            };
            userErrors: {
                field: string;
                message: string;
            }[];
        };
    };
}

declare const AppFunctionSetMutation: string;
interface AppFunctionSetMutationSchema {
    data: {
        appScriptSet: {
            userErrors: {
                field: string;
                message: string;
                tag: string;
            }[];
            appScript?: {
                uuid: string;
                appKey: string;
                configSchema: unknown;
                extensionPointName: string;
                title: string;
            };
        };
    };
}
interface AppFunctionSetVariables {
    uuid?: string;
    extensionPointName: string;
    title: string;
    description?: string;
    force?: boolean;
    schemaMajorVersion?: string;
    schemaMinorVersion?: string;
    scriptConfigVersion?: string;
    configurationUi: boolean;
    configurationDefinition?: string;
    moduleUploadUrl: string;
    library?: {
        language: string;
        version: string;
    };
    appBridge?: {
        createPath?: string;
        detailsPath?: string;
    };
    inputQuery?: string;
    apiVersion?: string;
}

declare const FindOrganizationBasicQuery: string;
interface FindOrganizationBasicQuerySchema {
    organizations: {
        nodes: {
            id: string;
            businessName: string;
            website: string;
            appsNext: boolean;
        }[];
    };
}

declare const index_FindOrganizationQuery: typeof FindOrganizationQuery;
type index_FindOrganizationQuerySchema = FindOrganizationQuerySchema;
type index_AllOrganizationsQuerySchemaOrganization = AllOrganizationsQuerySchemaOrganization;
type index_AllOrganizationsQuerySchema = AllOrganizationsQuerySchema;
declare const index_AllOrganizationsQuery: typeof AllOrganizationsQuery;
declare const index_CreateAppQuery: typeof CreateAppQuery;
type index_CreateAppQueryVariables = CreateAppQueryVariables;
type index_CreateAppQuerySchema = CreateAppQuerySchema;
declare const index_UpdateURLsQuery: typeof UpdateURLsQuery;
type index_UpdateURLsQueryVariables = UpdateURLsQueryVariables;
type index_UpdateURLsQuerySchema = UpdateURLsQuerySchema;
declare const index_FindAppQuery: typeof FindAppQuery;
type index_FindAppQuerySchema = FindAppQuerySchema;
declare const index_ExtensionUpdateDraftMutation: typeof ExtensionUpdateDraftMutation;
type index_ExtensionUpdateDraftInput = ExtensionUpdateDraftInput;
type index_ExtensionUpdateDraftPayload = ExtensionUpdateDraftPayload;
type index_ExtensionVersion = ExtensionVersion;
type index_ExtensionUpdateSchema = ExtensionUpdateSchema;
declare const index_GenerateSignedUploadUrl: typeof GenerateSignedUploadUrl;
type index_GenerateSignedUploadUrlVariables = GenerateSignedUploadUrlVariables;
type index_GenerateSignedUploadUrlSchema = GenerateSignedUploadUrlSchema;
declare const index_CreateDeployment: typeof CreateDeployment;
type index_ExtensionSettings = ExtensionSettings;
type index_CreateDeploymentVariables = CreateDeploymentVariables;
type index_CreateDeploymentSchema = CreateDeploymentSchema;
declare const index_AllStoresByOrganizationQuery: typeof AllStoresByOrganizationQuery;
type index_AllStoresByOrganizationSchema = AllStoresByOrganizationSchema;
declare const index_ConvertDevToTestStoreQuery: typeof ConvertDevToTestStoreQuery;
type index_ConvertDevToTestStoreVariables = ConvertDevToTestStoreVariables;
type index_ConvertDevToTestStoreSchema = ConvertDevToTestStoreSchema;
declare const index_ExtensionCreateQuery: typeof ExtensionCreateQuery;
type index_ExtensionCreateVariables = ExtensionCreateVariables;
type index_ExtensionCreateSchema = ExtensionCreateSchema;
declare const index_ExtensionSpecificationsQuery: typeof ExtensionSpecificationsQuery;
type index_ExtensionSpecificationsQueryVariables = ExtensionSpecificationsQueryVariables;
type index_ExtensionSpecificationsQuerySchema = ExtensionSpecificationsQuerySchema;
declare const index_AllAppExtensionRegistrationsQuery: typeof AllAppExtensionRegistrationsQuery;
type index_AllAppExtensionRegistrationsQueryVariables = AllAppExtensionRegistrationsQueryVariables;
type index_AllAppExtensionRegistrationsQuerySchema = AllAppExtensionRegistrationsQuerySchema;
declare const index_FindProductVariantQuery: typeof FindProductVariantQuery;
type index_FindProductVariantSchema = FindProductVariantSchema;
declare const index_ScriptServiceProxyQuery: typeof ScriptServiceProxyQuery;
type index_ScriptServiceProxyQuerySchema = ScriptServiceProxyQuerySchema;
declare const index_GetAppFunctionsQuery: typeof GetAppFunctionsQuery;
declare const index_ModuleUploadUrlGenerateMutation: typeof ModuleUploadUrlGenerateMutation;
type index_ModuleUploadUrlGenerateMutationSchema = ModuleUploadUrlGenerateMutationSchema;
declare const index_AppFunctionSetMutation: typeof AppFunctionSetMutation;
type index_AppFunctionSetMutationSchema = AppFunctionSetMutationSchema;
type index_AppFunctionSetVariables = AppFunctionSetVariables;
declare const index_FindOrganizationBasicQuery: typeof FindOrganizationBasicQuery;
type index_FindOrganizationBasicQuerySchema = FindOrganizationBasicQuerySchema;
declare namespace index {
  export {
    index_FindOrganizationQuery as FindOrganizationQuery,
    index_FindOrganizationQuerySchema as FindOrganizationQuerySchema,
    index_AllOrganizationsQuerySchemaOrganization as AllOrganizationsQuerySchemaOrganization,
    index_AllOrganizationsQuerySchema as AllOrganizationsQuerySchema,
    index_AllOrganizationsQuery as AllOrganizationsQuery,
    index_CreateAppQuery as CreateAppQuery,
    index_CreateAppQueryVariables as CreateAppQueryVariables,
    index_CreateAppQuerySchema as CreateAppQuerySchema,
    index_UpdateURLsQuery as UpdateURLsQuery,
    index_UpdateURLsQueryVariables as UpdateURLsQueryVariables,
    index_UpdateURLsQuerySchema as UpdateURLsQuerySchema,
    index_FindAppQuery as FindAppQuery,
    index_FindAppQuerySchema as FindAppQuerySchema,
    index_ExtensionUpdateDraftMutation as ExtensionUpdateDraftMutation,
    index_ExtensionUpdateDraftInput as ExtensionUpdateDraftInput,
    index_ExtensionUpdateDraftPayload as ExtensionUpdateDraftPayload,
    index_ExtensionVersion as ExtensionVersion,
    index_ExtensionUpdateSchema as ExtensionUpdateSchema,
    index_GenerateSignedUploadUrl as GenerateSignedUploadUrl,
    index_GenerateSignedUploadUrlVariables as GenerateSignedUploadUrlVariables,
    index_GenerateSignedUploadUrlSchema as GenerateSignedUploadUrlSchema,
    index_CreateDeployment as CreateDeployment,
    index_ExtensionSettings as ExtensionSettings,
    index_CreateDeploymentVariables as CreateDeploymentVariables,
    index_CreateDeploymentSchema as CreateDeploymentSchema,
    index_AllStoresByOrganizationQuery as AllStoresByOrganizationQuery,
    index_AllStoresByOrganizationSchema as AllStoresByOrganizationSchema,
    index_ConvertDevToTestStoreQuery as ConvertDevToTestStoreQuery,
    index_ConvertDevToTestStoreVariables as ConvertDevToTestStoreVariables,
    index_ConvertDevToTestStoreSchema as ConvertDevToTestStoreSchema,
    index_ExtensionCreateQuery as ExtensionCreateQuery,
    index_ExtensionCreateVariables as ExtensionCreateVariables,
    index_ExtensionCreateSchema as ExtensionCreateSchema,
    index_ExtensionSpecificationsQuery as ExtensionSpecificationsQuery,
    index_ExtensionSpecificationsQueryVariables as ExtensionSpecificationsQueryVariables,
    index_ExtensionSpecificationsQuerySchema as ExtensionSpecificationsQuerySchema,
    index_AllAppExtensionRegistrationsQuery as AllAppExtensionRegistrationsQuery,
    index_AllAppExtensionRegistrationsQueryVariables as AllAppExtensionRegistrationsQueryVariables,
    index_AllAppExtensionRegistrationsQuerySchema as AllAppExtensionRegistrationsQuerySchema,
    index_FindProductVariantQuery as FindProductVariantQuery,
    index_FindProductVariantSchema as FindProductVariantSchema,
    index_ScriptServiceProxyQuery as ScriptServiceProxyQuery,
    index_ScriptServiceProxyQuerySchema as ScriptServiceProxyQuerySchema,
    index_GetAppFunctionsQuery as GetAppFunctionsQuery,
    index_ModuleUploadUrlGenerateMutation as ModuleUploadUrlGenerateMutation,
    index_ModuleUploadUrlGenerateMutationSchema as ModuleUploadUrlGenerateMutationSchema,
    index_AppFunctionSetMutation as AppFunctionSetMutation,
    index_AppFunctionSetMutationSchema as AppFunctionSetMutationSchema,
    index_AppFunctionSetVariables as AppFunctionSetVariables,
    index_FindOrganizationBasicQuery as FindOrganizationBasicQuery,
    index_FindOrganizationBasicQuerySchema as FindOrganizationBasicQuerySchema,
  };
}

declare const api_admin: typeof admin;
declare namespace api {
  export {
    api_admin as admin,
    partners$2 as partners,
    index as graphql,
  };
}

declare function zip(inputDirectory: string, outputZipPath: string): Promise<void>;

declare const archiver_zip: typeof zip;
declare namespace archiver {
  export {
    archiver_zip as zip,
  };
}

declare const InvalidChecksumError: ({ file, expected, got }: {
    file: string;
    expected: string;
    got: string;
}) => Abort;
/**
 * Given a local file and a URL pointing to a remote file representing the MD5 of a local file,
 * it validates the authenticity of the binary using an MD5 checksum.
 * @param options: The file to validate and the URL that points to the file containing the MD5.
 */
declare function validateMD5({ file, md5FileURL }: {
    file: string;
    md5FileURL: string;
}): Promise<void>;

declare const checksum_InvalidChecksumError: typeof InvalidChecksumError;
declare const checksum_validateMD5: typeof validateMD5;
declare namespace checksum {
  export {
    checksum_InvalidChecksumError as InvalidChecksumError,
    checksum_validateMD5 as validateMD5,
  };
}

/**
 * An object that contains the flags that
 * are shared across all the commands.
 */
declare const globalFlags: {
    verbose: _oclif_core_lib_interfaces.BooleanFlag<boolean>;
};

declare const cli_globalFlags: typeof globalFlags;
declare namespace cli {
  export {
    cli_globalFlags as globalFlags,
  };
}

/**
 * Error that's thrown when the .env is not found.
 * @param path {string} Path to the .env file.
 * @returns {Abort} An abort error.
 */
declare const DotEnvNotFoundError: (path: string) => Abort;
/**
 * This interface represents a .env file.
 */
interface DotEnvFile {
    /**
     * Path to the .env file.
     */
    path: string;
    /**
     * Variables of the .env file.
     */
    variables: {
        [name: string]: string;
    };
}
declare function read$1(path: string): Promise<DotEnvFile>;
/**
 * Writes a .env file to disk.
 * @param file {DotEnvFile} .env file to be written.
 */
declare function write$1(file: DotEnvFile): Promise<void>;

declare const dotEnv_DotEnvNotFoundError: typeof DotEnvNotFoundError;
type dotEnv_DotEnvFile = DotEnvFile;
declare namespace dotEnv {
  export {
    dotEnv_DotEnvNotFoundError as DotEnvNotFoundError,
    dotEnv_DotEnvFile as DotEnvFile,
    read$1 as read,
    write$1 as write,
  };
}

/**
 * It returns true if the terminal is interactive.
 * @returns {boolean} True if the terminal is interactive.
 */
declare function isTerminalInteractive(): boolean;
/**
 * Returns the path to the user's home directory.
 * @returns {string} The path to the user's home directory.
 */
declare function homeDirectory(): string;
/**
 * Returns true if the CLI is running in debug mode.
 * @param env The environment variables from the environment of the current process.
 * @returns true if SHOPIFY_CONFIG is debug
 */
declare function isDebug(env?: NodeJS.ProcessEnv): boolean;
/**
 * Returns true if the CLI is running in verbose mode.
 * @param env The environment variables from the environment of the current process.
 * @returns true if SHOPIFY_FLAG_VERBOSE is truthy or the flag --verbose has been passed
 */
declare function isVerbose(env?: NodeJS.ProcessEnv): boolean;
/**
 * Returns true if the environment in which the CLI is running is either
 * a local environment (where dev is present) or a cloud environment (spin).
 * @returns {boolean} True if the CLI is used in a Shopify environment.
 */
declare function isShopify(env?: NodeJS.ProcessEnv): Promise<boolean>;
/**
 * This variable is used when running unit tests to indicate that the CLI's business logic
 * is run as a subject of a unit test. We can use this variable to disable output through
 * the standard streams.
 * @param env The environment variables from the environment of the current process.
 * @returns True if the SHOPIFY_UNIT_TEST environment variable is truthy.
 */
declare function isUnitTest(env?: NodeJS.ProcessEnv): boolean;
/**
 * Returns true if reporting analytics is enabled.
 * @param env The environment variables from the environment of the current process.
 * @returns true unless SHOPIFY_CLI_NO_ANALYTICS is truthy.
 */
declare function analyticsDisabled(env?: NodeJS.ProcessEnv): boolean;
/**
 * Returns whether the environment has Git available.
 * @returns {Promise<boolean>} A promise that resolves with the value.
 */
declare function hasGit(): Promise<boolean>;

declare const local_isTerminalInteractive: typeof isTerminalInteractive;
declare const local_homeDirectory: typeof homeDirectory;
declare const local_isDebug: typeof isDebug;
declare const local_isVerbose: typeof isVerbose;
declare const local_isShopify: typeof isShopify;
declare const local_isUnitTest: typeof isUnitTest;
declare const local_analyticsDisabled: typeof analyticsDisabled;
declare const local_hasGit: typeof hasGit;
declare namespace local {
  export {
    local_isTerminalInteractive as isTerminalInteractive,
    local_homeDirectory as homeDirectory,
    local_isDebug as isDebug,
    local_isVerbose as isVerbose,
    local_isShopify as isShopify,
    local_isUnitTest as isUnitTest,
    local_analyticsDisabled as analyticsDisabled,
    local_hasGit as hasGit,
  };
}

/**
 * Enum that represents the environment to use for a given service.
 * @readonly
 * @enum {number}
 */
declare enum Environment {
    Local = "local",
    Production = "production",
    Spin = "spin"
}

/**
 * Returns the environment to be used for the interactions with the partners' CLI API.
 * @param env The environment variables from the environment of the current process.
 */
declare function partners$1(env?: NodeJS.ProcessEnv): Environment;
/**
 * Returns the environment to be used for the interactions with the admin API.
 * @param env The environment variables from the environment of the current process.
 */
declare function shopify$1(env?: NodeJS.ProcessEnv): Environment;
/**
 * Returns the environment to be used for the interactions with identity.
 * @param env The environment variables from the environment of the current process.
 */
declare function identity$1(env?: NodeJS.ProcessEnv): Environment;

declare namespace service {
  export {
    partners$1 as partners,
    shopify$1 as shopify,
    identity$1 as identity,
  };
}

declare const CouldntObtainPartnersSpinFQDNError: Abort;
declare const CouldntObtainIdentitySpinFQDNError: Abort;
declare const CouldntObtainShopifySpinFQDNError: Abort;
declare const NotProvidedStoreFQDNError: Abort;
/**
 * It returns the Partners' API service we should interact with.
 * @returns {string} Fully-qualified domain of the partners service we should interact with.
 */
declare function partners(): Promise<string>;
/**
 * It returns the Identity service we should interact with.
 * @returns {string} Fully-qualified domain of the Identity service we should interact with.
 */
declare function identity(): Promise<string>;
/**
 * It returns the Shopify service we should interact with.
 * Note the same fqdn is sued for the Admin and the Storefront Renderer APIs.
 * @returns {string} Fully-qualified domain of the Shopify service we should interact with.
 */
declare function shopify(options?: {
    storeFqdn?: string;
}): Promise<string>;

declare const fqdn_CouldntObtainPartnersSpinFQDNError: typeof CouldntObtainPartnersSpinFQDNError;
declare const fqdn_CouldntObtainIdentitySpinFQDNError: typeof CouldntObtainIdentitySpinFQDNError;
declare const fqdn_CouldntObtainShopifySpinFQDNError: typeof CouldntObtainShopifySpinFQDNError;
declare const fqdn_NotProvidedStoreFQDNError: typeof NotProvidedStoreFQDNError;
declare const fqdn_partners: typeof partners;
declare const fqdn_identity: typeof identity;
declare const fqdn_shopify: typeof shopify;
declare namespace fqdn {
  export {
    fqdn_CouldntObtainPartnersSpinFQDNError as CouldntObtainPartnersSpinFQDNError,
    fqdn_CouldntObtainIdentitySpinFQDNError as CouldntObtainIdentitySpinFQDNError,
    fqdn_CouldntObtainShopifySpinFQDNError as CouldntObtainShopifySpinFQDNError,
    fqdn_NotProvidedStoreFQDNError as NotProvidedStoreFQDNError,
    fqdn_partners as partners,
    fqdn_identity as identity,
    fqdn_shopify as shopify,
  };
}

/**
 * Returns whether an environment variable value represents a truthy value.
 * @param variable {string | undefined} Given a environment variable value, it returns true if it represents a truthy value.
 * @returns {boolean}
 */
declare function isTruthy(variable: string | undefined): boolean;

declare const utilities_isTruthy: typeof isTruthy;
declare namespace utilities {
  export {
    utilities_isTruthy as isTruthy,
  };
}

declare const environment_local: typeof local;
declare const environment_service: typeof service;
declare const environment_fqdn: typeof fqdn;
declare const environment_utilities: typeof utilities;
declare namespace environment {
  export {
    environment_local as local,
    environment_service as service,
    environment_fqdn as fqdn,
    environment_utilities as utilities,
  };
}

declare function stripUp(path: string, strip: number): string;
/**
 * Creates a temporary directory and ties its lifecycle ot the lifecycle of the callback.
 * @param callback - The callback that receives the temporary directory.
 */
declare function inTemporaryDirectory<T>(callback: (tmpDir: string) => T | Promise<T>): Promise<T>;
/**
 * It reads a file and returns its content as a string using the
 * utf-8 encoding
 * @param path {string} Path to the file to read.
 * @returns {Promise<string>} A promise that resolves with the content of the file.
 */
declare function read(path: string, options?: object): Promise<string>;
declare function readSync(path: string, options?: object): string;
/**
 * Copies a file
 * @param from {string} Path to the directory or file to be copied.
 * @param to {string} Destination path.
 */
declare function copy(from: string, to: string): Promise<void>;
declare function touch(path: string): Promise<void>;
declare function write(path: string, data: string): Promise<void>;
declare function writeSync(path: string, data: string): void;
declare function append(path: string, data: string): Promise<void>;
declare function mkdir(path: string): Promise<void>;
declare function mkdirSync(path: string): void;
declare function remove$1(path: string): Promise<void>;
declare function rmdir(path: string, { force }?: {
    force?: boolean;
}): Promise<void>;
declare function mkTmpDir(): Promise<string>;
declare function isDirectory(path: string): Promise<boolean>;
declare function size(path: string): Promise<number>;
declare function sizeSync(path: string): number;
/**
 * Moves a file.
 * @param src {string} File to be moved.
 * @param dest {string} Path to be moved to.
 * @param options {object} Moving options.
 */
declare function move(src: string, dest: string, options?: {
    overwrite?: boolean;
}): Promise<void>;
/**
 * Changes the permissions of a directory or file.
 * @param path {string} Path to the file or directory whose permissions will be modified.
 * @param mode {string | numbers} Permissions to set to the file or directory.
 */
declare function chmod(path: string, mode: number | string): Promise<void>;
/**
 * Checks if a file has executable permissions.
 * @param path {string} Path to the file whose permissions will be checked.
 */
declare function hasExecutablePermissions(path: string): Promise<boolean>;
/**
 * Returns true if a file or directory exists
 * @param path {string} Path to the directory or file.
 * @returns {boolean} True if it exists.
 */
declare function exists(path: string): Promise<boolean>;
/**
 * Format a string using prettier. Return the formatted content.
 */
declare function format(content: string, options: {
    path: string;
}): Promise<string>;

declare const file_stripUp: typeof stripUp;
declare const file_inTemporaryDirectory: typeof inTemporaryDirectory;
declare const file_read: typeof read;
declare const file_readSync: typeof readSync;
declare const file_copy: typeof copy;
declare const file_touch: typeof touch;
declare const file_write: typeof write;
declare const file_writeSync: typeof writeSync;
declare const file_append: typeof append;
declare const file_mkdir: typeof mkdir;
declare const file_mkdirSync: typeof mkdirSync;
declare const file_rmdir: typeof rmdir;
declare const file_mkTmpDir: typeof mkTmpDir;
declare const file_isDirectory: typeof isDirectory;
declare const file_size: typeof size;
declare const file_sizeSync: typeof sizeSync;
declare const file_move: typeof move;
declare const file_chmod: typeof chmod;
declare const file_hasExecutablePermissions: typeof hasExecutablePermissions;
declare const file_exists: typeof exists;
declare const file_format: typeof format;
declare namespace file {
  export {
    file_stripUp as stripUp,
    file_inTemporaryDirectory as inTemporaryDirectory,
    file_read as read,
    file_readSync as readSync,
    file_copy as copy,
    file_touch as touch,
    file_write as write,
    file_writeSync as writeSync,
    file_append as append,
    file_mkdir as mkdir,
    file_mkdirSync as mkdirSync,
    remove$1 as remove,
    file_rmdir as rmdir,
    file_mkTmpDir as mkTmpDir,
    file_isDirectory as isDirectory,
    file_size as size,
    file_sizeSync as sizeSync,
    file_move as move,
    file_chmod as chmod,
    file_hasExecutablePermissions as hasExecutablePermissions,
    file_exists as exists,
    file_format as format,
  };
}

declare const factory: simple_git.SimpleGitFactory;
declare const GitNotPresentError: () => Abort;
declare function initializeRepository(directory: string): Promise<void>;
declare function downloadRepository({ repoUrl, destination, progressUpdater, shallow, }: {
    repoUrl: string;
    destination: string;
    progressUpdater?: (statusString: string) => void;
    shallow?: boolean;
}): Promise<void>;
/**
 * If "git" is not present in the environment it throws
 * an abort error.
 */
declare function ensurePresentOrAbort(): Promise<void>;

declare const git_factory: typeof factory;
declare const git_GitNotPresentError: typeof GitNotPresentError;
declare const git_initializeRepository: typeof initializeRepository;
declare const git_downloadRepository: typeof downloadRepository;
declare const git_ensurePresentOrAbort: typeof ensurePresentOrAbort;
declare namespace git {
  export {
    git_factory as factory,
    git_GitNotPresentError as GitNotPresentError,
    git_initializeRepository as initializeRepository,
    git_downloadRepository as downloadRepository,
    git_ensurePresentOrAbort as ensurePresentOrAbort,
  };
}

interface GithubRelease {
    id: number;
    url: string;
    tag_name: string;
    name: string;
    body: string;
    draft: boolean;
    prerelease: boolean;
    created_at: string;
    published_at: string;
    tarball_url: string;
}
interface Options {
    filter: (release: GithubRelease) => boolean;
}
declare function getLatestRelease(user: string, repo: string, { filter }?: Options): Promise<GithubRelease>;
declare function parseRepoUrl(src: string): {
    full: string;
    site: string;
    user: string;
    name: string;
    ref: string;
    subDirectory: string;
    ssh: string;
    http: string;
};
interface GithubRepoReference {
    repoBaseUrl: string;
    branch?: string;
    filePath?: string;
}
declare function parseGithubRepoReference(src: string): GithubRepoReference;

type github_GithubRelease = GithubRelease;
declare const github_getLatestRelease: typeof getLatestRelease;
declare const github_parseRepoUrl: typeof parseRepoUrl;
type github_GithubRepoReference = GithubRepoReference;
declare const github_parseGithubRepoReference: typeof parseGithubRepoReference;
declare namespace github {
  export {
    github_GithubRelease as GithubRelease,
    github_getLatestRelease as getLatestRelease,
    github_parseRepoUrl as parseRepoUrl,
    github_GithubRepoReference as GithubRepoReference,
    github_parseGithubRepoReference as parseGithubRepoReference,
  };
}

declare function generate(suffix: string): string;

declare const haiku_generate: typeof generate;
declare namespace haiku {
  export {
    haiku_generate as generate,
  };
}

declare type Response = ReturnType<typeof nodeFetch>;
/**
 * An interface that abstracts way node-fetch. When Node has built-in
 * support for "fetch" in the standard library, we can drop the node-fetch
 * dependency from here.
 * Note that we are exposing types from "node-fetch". The reason being is that
 * they are consistent with the Web API so if we drop node-fetch in the future
 * it won't require changes from the callers.
 * @param url {RequestInfo} This defines the resource that you wish to fetch.
 * @param init {RequestInit} An object containing any custom settings that you want to apply to the request
 * @returns A promise that resolves with the response.
 */
declare function fetch(url: RequestInfo, init?: RequestInit): Response;

declare function formData(): FormData;

declare const http_fetch: typeof fetch;
declare const http_formData: typeof formData;
declare namespace http {
  export {
    http_fetch as fetch,
    http_formData as formData,
  };
}

/**
 * Generates and returns a random UUID.
 * @returns {string} The random UUID generated.
 */
declare const generateRandomUUID: () => string;
declare const generateShortId: () => string;

declare const id_generateRandomUUID: typeof generateRandomUUID;
declare const id_generateShortId: typeof generateShortId;
declare namespace id {
  export {
    id_generateRandomUUID as generateRandomUUID,
    id_generateShortId as generateShortId,
  };
}

interface JSON {
    [key: string]: JSONValue;
}
declare type JSONValue = string | number | boolean | JSON | JSONValue[];
interface PackageJSON extends JSON {
    name: string;
    author: string;
    dependencies: {
        [key: string]: string;
    };
    devDependencies: {
        [key: string]: string;
    };
    resolutions: {
        [key: string]: string;
    };
    overrides: {
        [key: string]: string;
    };
    scripts: {
        [key: string]: string;
    };
}
declare function readPackageJSON(directory: string): Promise<PackageJSON>;
declare function writePackageJSON(directory: string, packageJSON: JSON): Promise<void>;
declare function updateAppData(packageJSON: JSON, name: string): Promise<void>;

type npm_PackageJSON = PackageJSON;
declare const npm_readPackageJSON: typeof readPackageJSON;
declare const npm_writePackageJSON: typeof writePackageJSON;
declare const npm_updateAppData: typeof updateAppData;
declare namespace npm {
  export {
    npm_PackageJSON as PackageJSON,
    npm_readPackageJSON as readPackageJSON,
    npm_writePackageJSON as writePackageJSON,
    npm_updateAppData as updateAppData,
  };
}

declare const username: (platform?: typeof platform) => Promise<string | null>;
/**
 * Returns the platform and architecture.
 * @returns {{platform: string, arch: string}} Returns the current platform and architecture.
 */
declare const platformAndArch: (platform?: typeof platform) => {
    platform: string;
    arch: string;
};

declare const os_username: typeof username;
declare const os_platformAndArch: typeof platformAndArch;
declare namespace os {
  export {
    os_username as username,
    os_platformAndArch as platformAndArch,
  };
}

/**
 * Given an absolute filesystem path, it makes it relative to
 * the current working directory. This is useful when logging paths
 * to allow the users to click on the file and let the OS open it
 * in the editor of choice.
 * @param path {string} Path to relativize
 * @returns {string} Relativized path.
 */
declare function relativize(path: string): string;
/**
 * Given a module's import.meta.url it returns the directory containing the module.
 * @param moduleURL {string} The value of import.meta.url in the context of the caller module.
 * @returns {string} The path to the directory containing the caller module.
 */
declare function moduleDirectory(moduleURL: string): string;

var path = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  relativize: relativize,
  moduleDirectory: moduleDirectory,
  findUp: findUp,
  glob: fastGlob,
  pathToFileURL: pathToFileURL
}, [pathe]);

interface TunnelPlugin {
    start: (options: TunnelStartOptions) => Promise<string>;
}
interface TunnelStartOptions {
    port: number;
}
declare function lookupTunnelPlugin(plugins: Plugin[]): Promise<TunnelPlugin | undefined>;

declare const plugins_lookupTunnelPlugin: typeof lookupTunnelPlugin;
declare namespace plugins {
  export {
    plugins_lookupTunnelPlugin as lookupTunnelPlugin,
  };
}

/**
 * Returns an available port in the current environment.
 * @returns {Promise<number>} A promise that resolves with an availabe port.
 */
declare function getRandomPort(): Promise<number>;

declare const port_getRandomPort: typeof getRandomPort;
declare namespace port {
  export {
    port_getRandomPort as getRandomPort,
  };
}

/**
 * Execute CLI 2.0 commands.
 * Installs a version of RubyCLI as a vendor dependency in a hidden folder in the system.
 * User must have a valid ruby+bundler environment to run any command.
 *
 * @param args {string[]} List of argumets to execute. (ex: ['theme', 'pull'])
 * @param adminSession {AdminSession} Contains token and store to pass to CLI 2.0, which will be set as environment variables
 */
declare function execCLI(args: string[], adminSession?: AdminSession): Promise<void>;
interface ExecThemeCheckCLIOptions {
    directories: string[];
    args?: string[];
    stdout: Writable;
    stderr: Writable;
}
declare function execThemeCheckCLI({ directories, args, stdout, stderr, }: ExecThemeCheckCLIOptions): Promise<void[]>;
declare function version$1(): Promise<string | undefined>;

declare const ruby_execCLI: typeof execCLI;
declare const ruby_execThemeCheckCLI: typeof execThemeCheckCLI;
declare namespace ruby {
  export {
    ruby_execCLI as execCLI,
    ruby_execThemeCheckCLI as execThemeCheckCLI,
    version$1 as version,
  };
}

declare namespace schema {
  export {
    z as define,
  };
}

declare const semver_coerce: typeof coerce;
declare namespace semver {
  export {
    semver$1 as Version,
    semver_coerce as coerce,
  };
}

interface CachedAppInfo {
    directory: string;
    appId: string;
    title?: string;
    orgId?: string;
    storeFqdn?: string;
}
interface ConfSchema {
    appInfo: CachedAppInfo[];
    themeStore: string;
}
declare const cliKit: Conf<ConfSchema>;
declare function remove(): void;
declare function getAppInfo(directory: string): CachedAppInfo | undefined;
declare function setAppInfo(options: {
    directory: string;
    appId: string;
    title?: string;
    storeFqdn?: string;
    orgId?: string;
}): void;
declare function clearAppInfo(directory: string): void;
declare function getThemeStore(): string | undefined;
declare function setThemeStore(store: string): void;

type store_CachedAppInfo = CachedAppInfo;
declare const store_cliKit: typeof cliKit;
declare const store_remove: typeof remove;
declare const store_getAppInfo: typeof getAppInfo;
declare const store_setAppInfo: typeof setAppInfo;
declare const store_clearAppInfo: typeof clearAppInfo;
declare const store_getThemeStore: typeof getThemeStore;
declare const store_setThemeStore: typeof setThemeStore;
declare namespace store {
  export {
    store_CachedAppInfo as CachedAppInfo,
    store_cliKit as cliKit,
    store_remove as remove,
    store_getAppInfo as getAppInfo,
    store_setAppInfo as setAppInfo,
    store_clearAppInfo as clearAppInfo,
    store_getThemeStore as getThemeStore,
    store_setThemeStore as setThemeStore,
  };
}

/** Returns a random string */
declare function randomHex(size: number): string;
declare function generateRandomChallengePair(): {
    codeVerifier: string;
    codeChallenge: string;
};
/**
 * Given a string, it returns it with the first letter capitalized.
 * @param string {string} String whose first letter will be caplitalized.
 * @returns The given string with its first letter capitalized.
 */
declare function capitalize(string: string): string;
/**
 * Given a store, returns a valid store fqdn removing protocol and adding .myshopify.com domain
 * @param store Original store name provided by the user
 * @returns a valid store fqdn
 */
declare function normalizeStoreName(store: string): string;

declare const string_randomHex: typeof randomHex;
declare const string_generateRandomChallengePair: typeof generateRandomChallengePair;
declare const string_capitalize: typeof capitalize;
declare const string_normalizeStoreName: typeof normalizeStoreName;
declare namespace string {
  export {
    string_randomHex as randomHex,
    string_generateRandomChallengePair as generateRandomChallengePair,
    string_capitalize as capitalize,
    string_normalizeStoreName as normalizeStoreName,
    camelCase as camelize,
    paramCase as hyphenize,
    snakeCase as underscore,
    constantCase as constantize,
  };
}

interface ExecOptions {
    cwd?: string;
    env?: {
        [key: string]: string | undefined;
    };
    stdout?: Writable | 'inherit';
    stderr?: Writable;
    stdio?: Readable | 'inherit';
    stdin?: string;
    signal?: AbortSignal;
}
declare type WritableExecOptions = Omit<ExecOptions, 'stdout'> & {
    stdout?: Writable;
};
declare const open: (url: string) => Promise<void>;
/**
 * Runs a command asynchronously, aggregates the stdout data, and returns it.
 * @param command {string} Command to be executed.
 * @param args {string[]} Arguments to pass to the command.
 * @returns A promise that resolves with the aggregatted stdout of the command.
 */
declare const captureOutput: (command: string, args: string[], options?: ExecOptions) => Promise<string>;
declare const exec: (command: string, args: string[], options?: ExecOptions) => Promise<void>;
interface ConcurrentExecCommand {
    prefix: string;
    executable: string;
    args: string[];
    cwd: string;
}
/**
 * Runs commands concurrently and combines the standard output and error data
 * into a single stream that differenciates the sources using a colored prefix:
 *
 * Example:
 *   [my-extension] Log coming from my-extension
 *   [my-script] Log coming from my script
 *
 * If one of the processes fails, it aborts the running ones and exits with that error.
 * @param commands {ConcurrentExecCommand[]} Commands to execute.
 */
declare const concurrentExec: (commands: ConcurrentExecCommand[]) => Promise<void>;
/**
 * Displays a large file using the terminal pager set by the user, or a
 * reasonable default for the user's OS:
 *
 * @param filename string The path to the file to be displayed.
 */
declare function page(filename: string): Promise<void>;
declare function sleep(seconds: number): Promise<unknown>;

type system_ExecOptions = ExecOptions;
type system_WritableExecOptions = WritableExecOptions;
declare const system_open: typeof open;
declare const system_captureOutput: typeof captureOutput;
declare const system_exec: typeof exec;
declare const system_concurrentExec: typeof concurrentExec;
declare const system_page: typeof page;
declare const system_sleep: typeof sleep;
declare namespace system {
  export {
    system_ExecOptions as ExecOptions,
    system_WritableExecOptions as WritableExecOptions,
    system_open as open,
    system_captureOutput as captureOutput,
    system_exec as exec,
    system_concurrentExec as concurrentExec,
    system_page as page,
    system_sleep as sleep,
  };
}

declare function create(templateContent: string): (data: object) => Promise<string>;
/**
 * Given a directory, it traverses the files and directories recursively
 * and replaces variables in directory and file names, and files' content
 * using the Liquid template engine.
 * Files indicate that they are liquid template by using the .liquid extension.
 * @param from {string} Directory that contains the template.
 * @param to {string} Output directory.
 * @param data {string} Data to feed the template engine.
 */
declare function recursiveDirectoryCopy(from: string, to: string, data: object): Promise<void>;

declare const template_create: typeof create;
declare const template_recursiveDirectoryCopy: typeof recursiveDirectoryCopy;
declare namespace template {
  export {
    template_create as create,
    template_recursiveDirectoryCopy as recursiveDirectoryCopy,
  };
}

/**
 * Creates a temporary directory and ties its lifeclcycle to the lifecycle of the callback.
 * @param callback {(string) => void} Callback to execute. When the callback exits, the temporary directory is destroyed.
 * @returns {Promise<T>} Promise that resolves with the value returned by the callback.
 */
declare function directory<T>(callback: (directory: string) => Promise<T>): Promise<T>;

declare const temporary_directory: typeof directory;
declare namespace temporary {
  export {
    temporary_directory as directory,
  };
}

declare function decode$1(input: string): object;
declare function encode$1(content: toml$1.JsonMap): string;

declare namespace toml {
  export {
    decode$1 as decode,
    encode$1 as encode,
  };
}

interface BaseQuestion<TName extends string> {
    name: TName;
    message: string;
    preface?: string;
    validate?: (value: string) => string | true;
    default?: string;
    result?: (value: string) => string | boolean;
}
declare type InputQuestion<TName extends string> = BaseQuestion<TName> & {
    type: 'input';
};
declare type SelectQuestion<TName extends string> = BaseQuestion<TName> & {
    type: 'select';
    choices: string[] | {
        name: string;
        value: string;
    }[];
};
declare type AutocompleteQuestion<TName extends string> = BaseQuestion<TName> & {
    type: 'autocomplete';
    choices: string[] | {
        name: string;
        value: string;
    }[];
};
declare type PasswordQuestion<TName extends string> = BaseQuestion<TName> & {
    type: 'password';
};
declare type Question<TName extends string = string> = InputQuestion<TName> | SelectQuestion<TName> | AutocompleteQuestion<TName> | PasswordQuestion<TName>;
declare const prompt: <TName extends string & keyof TAnswers, TAnswers extends { [key in TName]: string; } = { [key_1 in TName]: string; }>(questions: readonly Question<TName>[], debugForceInquirer?: boolean) => Promise<TAnswers>;
declare function nonEmptyDirectoryPrompt(directory: string): Promise<void>;
declare const keypress: () => Promise<void>;

type ui_InputQuestion<TName extends string> = InputQuestion<TName>;
type ui_SelectQuestion<TName extends string> = SelectQuestion<TName>;
type ui_AutocompleteQuestion<TName extends string> = AutocompleteQuestion<TName>;
type ui_PasswordQuestion<TName extends string> = PasswordQuestion<TName>;
type ui_Question<TName extends string = string> = Question<TName>;
declare const ui_prompt: typeof prompt;
declare const ui_nonEmptyDirectoryPrompt: typeof nonEmptyDirectoryPrompt;
declare const ui_keypress: typeof keypress;
declare const ui_Listr: typeof Listr;
declare const ui_ListrTaskWrapper: typeof ListrTaskWrapper;
declare const ui_ListrDefaultRenderer: typeof ListrDefaultRenderer;
declare const ui_ListrTask: typeof ListrTask;
declare namespace ui {
  export {
    ui_InputQuestion as InputQuestion,
    ui_SelectQuestion as SelectQuestion,
    ui_AutocompleteQuestion as AutocompleteQuestion,
    ui_PasswordQuestion as PasswordQuestion,
    ui_Question as Question,
    ui_prompt as prompt,
    ui_nonEmptyDirectoryPrompt as nonEmptyDirectoryPrompt,
    ui_keypress as keypress,
    ui_Listr as Listr,
    ui_ListrTaskWrapper as ListrTaskWrapper,
    ui_ListrDefaultRenderer as ListrDefaultRenderer,
    ui_ListrTask as ListrTask,
  };
}

/**
 * Returns the latest available version of an NPM package.
 * @param name {string} The name of the NPM package.
 * @returns A promise to get the latest available version of a package.
 */
declare function latestNpmPackageVersion(name: string): Promise<string>;
declare function cliVersion(): string;

declare const version_latestNpmPackageVersion: typeof latestNpmPackageVersion;
declare const version_cliVersion: typeof cliVersion;
declare namespace version {
  export {
    version_latestNpmPackageVersion as latestNpmPackageVersion,
    version_cliVersion as cliVersion,
  };
}

/**
 * Check if user editor is VS Code
 */
declare const isVSCode: (root?: string) => Promise<boolean>;
/**
 * Add VSCode extension recommendations
 */
declare function addRecommendedExtensions(directory: string, recommendations: string[]): Promise<void>;

declare const vscode_isVSCode: typeof isVSCode;
declare const vscode_addRecommendedExtensions: typeof addRecommendedExtensions;
declare namespace vscode {
  export {
    vscode_isVSCode as isVSCode,
    vscode_addRecommendedExtensions as addRecommendedExtensions,
  };
}

declare function decode(input: string): unknown;
declare function encode(content: unknown): string;

declare const yaml_decode: typeof decode;
declare const yaml_encode: typeof encode;
declare namespace yaml {
  export {
    yaml_decode as decode,
    yaml_encode as encode,
  };
}

export { abort, analytics, api, archiver, checksum, cli, constants, dependency, dotEnv as dotenv, environment, error, file, git, github, haiku, http, id, npm, os, output, path, plugins, port, ruby, schema, semver, session, store, string, system, template, temporary, toml, ui, version, vscode, yaml };
//# sourceMappingURL=index.d.ts.map
